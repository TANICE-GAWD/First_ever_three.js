<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Interactive Video Particles - Colored</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; }
  #fileInput { position:absolute; top:10px; left:10px; z-index:10; }
</style>
</head>
<body>
<input type="file" id="fileInput" accept="video/*">
<video id="video" loop muted playsinline style="display:none"></video>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';

// --- SCENE SETUP ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 5000);
camera.position.z = 800;

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
document.body.appendChild(renderer.domElement);

// --- VIDEO SETUP ---
const video = document.getElementById('video');
const sampler = document.createElement('canvas');
const ctx = sampler.getContext('2d');

// --- PARTICLE VARIABLES ---
let particleCount = 0;
let geometry, material, points;
const PARTICLE_SIZE = 3;
let DENSITY = 2;
let pointer = new THREE.Vector2(-9999,-9999);
let mouseDown = false;

// --- COLOR DEFINITIONS ---
const COLOR_BRIGHT = new THREE.Color(0xffffff); // high brightness
const COLOR_DARK = new THREE.Color(0x222222);   // low brightness
const COLOR_DEFAULT = new THREE.Color().setHSL(0.5,1,1); // cyan
const COLOR_HOVER = new THREE.Color().setHSL(0.15,1,0.5); // yellow/lime green

// --- POINTER EVENTS ---
window.addEventListener('mousemove', (e)=>{
  pointer.x = (e.clientX/window.innerWidth)*2-1;
  pointer.y = -(e.clientY/window.innerHeight)*2+1;
});
window.addEventListener('mouseleave', ()=>{ pointer.set(-9999,-9999); });
window.addEventListener('mousedown', ()=>{ mouseDown = true; });
window.addEventListener('mouseup', ()=>{ mouseDown = false; });

// --- FILE INPUT ---
document.getElementById('fileInput').addEventListener('change', (e)=>{
  const file = e.target.files[0];
  if(!file) return;
  const url = URL.createObjectURL(file);
  video.src = url;
  video.load();
  video.play();
  video.addEventListener('loadedmetadata', ()=>{
    initParticles(video.videoWidth, video.videoHeight);
  }, {once:true});
});

// --- INITIALIZE PARTICLES ---
function initParticles(w,h){
  const step = DENSITY;
  const cols = Math.floor(w/step);
  const rows = Math.floor(h/step);
  particleCount = cols*rows;

  sampler.width = cols;
  sampler.height = rows;

  geometry?.dispose();
  material?.dispose();
  if(points) scene.remove(points);

  const positions = new Float32Array(particleCount*3);
  const velocities = new Float32Array(particleCount*3);
  const sizes = new Float32Array(particleCount);
  const colors = new Float32Array(particleCount*3);

  let i=0;
  const halfW = cols/2;
  const halfH = rows/2;

  for(let y=0; y<rows; y++){
    for(let x=0; x<cols; x++){
      positions[i*3+0] = (x - halfW)*PARTICLE_SIZE;
      positions[i*3+1] = (halfH - y)*PARTICLE_SIZE;
      positions[i*3+2] = 0;
      velocities[i*3+0] = velocities[i*3+1] = velocities[i*3+2] = 0;
      sizes[i] = PARTICLE_SIZE;
      COLOR_DEFAULT.toArray(colors,i*3); // initial default cyan
      i++;
    }
  }

  geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
  geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities,3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes,1));
  geometry.setAttribute('customColor', new THREE.BufferAttribute(colors,3));

  material = new THREE.ShaderMaterial({
    vertexShader: `
      attribute float size;
      attribute vec3 customColor;
      varying vec3 vColor;
      void main(){
        vColor = customColor;
        vec4 mvPosition = modelViewMatrix*vec4(position,1.0);
        gl_PointSize = size * (300.0/-mvPosition.z);
        gl_Position = projectionMatrix*mvPosition;
      }
    `,
    fragmentShader: `
      varying vec3 vColor;
      void main(){
        float d = distance(gl_PointCoord, vec2(0.5));
        if(d>0.5) discard;
        gl_FragColor = vec4(vColor,1.0);
      }
    `,
    transparent:true,
    vertexColors:true
  });

  points = new THREE.Points(geometry, material);
  scene.add(points);
}

// --- UPDATE PARTICLES ---
function updateParticles(){
  if(!video || video.paused || video.readyState<2) return;
  ctx.drawImage(video,0,0,sampler.width,sampler.height);
  const img = ctx.getImageData(0,0,sampler.width,sampler.height).data;

  const posAttr = geometry.getAttribute('position');
  const velAttr = geometry.getAttribute('velocity');
  const sizeAttr = geometry.getAttribute('size');
  const colAttr = geometry.getAttribute('customColor');

  const positions = posAttr.array;
  const velocities = velAttr.array;
  const sizes = sizeAttr.array;
  const colors = colAttr.array;

  const time = performance.now()*0.001; // for animating color when mouse down

  let idx=0;
  for(let y=0; y<sampler.height; y++){
    for(let x=0; x<sampler.width; x++){
      const pixelIndex = (y*sampler.width+x)*4;
      const r = img[pixelIndex]/255;
      const g = img[pixelIndex+1]/255;
      const b = img[pixelIndex+2]/255;

      // brightness -> color mapping
      const brightness = 0.299*r + 0.587*g + 0.114*b;
      if(brightness>0.5){
        COLOR_BRIGHT.toArray(colors,idx*3);
      } else {
        COLOR_DARK.toArray(colors,idx*3);
      }

      // interaction
      const particlePos = new THREE.Vector3(positions[idx*3], positions[idx*3+1], positions[idx*3+2]);
      const mouse = new THREE.Vector3(pointer.x*window.innerWidth/2, pointer.y*window.innerHeight/2,0);
      const diff = new THREE.Vector3().subVectors(particlePos, mouse);
      const dist = diff.length();

      if(dist<100){
        const force = (100-dist)/100*5;
        velocities[idx*3] += diff.x/dist*force;
        velocities[idx*3+1] += diff.y/dist*force;

        // hover color
        COLOR_HOVER.toArray(colors,idx*3);
      }

      if(mouseDown && dist<150){
        const animHue = (0.5 + Math.sin(time*5))%1;
        const animColor = new THREE.Color().setHSL(animHue,1,0.5);
        animColor.toArray(colors,idx*3);
      }

      // apply velocity with easing
      velocities[idx*3] *= 0.85;
      velocities[idx*3+1] *= 0.85;
      positions[idx*3] += velocities[idx*3];
      positions[idx*3+1] += velocities[idx*3+1];

      // dynamic size based on distance
      sizes[idx] = PARTICLE_SIZE + (100-dist)/10 * (dist<100?1:0);

      idx++;
    }
  }

  posAttr.needsUpdate = true;
  velAttr.needsUpdate = true;
  sizeAttr.needsUpdate = true;
  colAttr.needsUpdate = true;
}

// --- ANIMATE ---
function animate(){
  requestAnimationFrame(animate);
  if(geometry) updateParticles();
  renderer.render(scene, camera);
}
animate();

// --- RESIZE ---
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
